{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hsvdotbeer Collate ALL the Huntsville beers. Check out the project's documentation . Prerequisites Docker Travis CLI Heroku Toolbelt Initialize the project Start the dev server for local development: docker-compose up Create a superuser to login to the admin: docker-compose run --rm web ./manage.py createsuperuser Continuous Deployment Deployment automated via Travis. When builds pass on the master or qa branch, Travis will deploy that branch to Heroku. Enable this by: Creating the production sever: heroku create hsv_dot_beer-prod --remote prod && \\ heroku addons:create newrelic:wayne --app hsv_dot_beer-prod && \\ heroku addons:create heroku-postgresql:hobby-dev --app hsv_dot_beer-prod && \\ heroku config:set DJANGO_SECRET=`openssl rand -base64 32` \\ DJANGO_AWS_ACCESS_KEY_ID=\"Add your id\" \\ DJANGO_AWS_SECRET_ACCESS_KEY=\"Add your key\" \\ DJANGO_AWS_STORAGE_BUCKET_NAME=\"hsv_dot_beer-prod\" \\ --app hsv_dot_beer-prod Creating the qa sever: heroku create `hsv_dot_beer-qa --remote qa && \\ heroku addons:create newrelic:wayne && \\ heroku addons:create heroku-postgresql:hobby-dev && \\ heroku config:set DJANGO_SECRET=`openssl rand -base64 32` \\ DJANGO_AWS_ACCESS_KEY_ID=\"Add your id\" \\ DJANGO_AWS_SECRET_ACCESS_KEY=\"Add your key\" \\ DJANGO_AWS_STORAGE_BUCKET_NAME=\"hsv_dot_beer-qa\" \\ Securely add your heroku credentials to travis so it can automatically deploy your changes. travis encrypt HEROKU_AUTH_TOKEN=\"$(heroku auth:token)\" --add Commit your changes and push to master and qa to trigger your first deploys: git commit -m \"ci(travis): added heroku credentials\" && \\ git push origin master && \\ git checkout -b qa && \\ git push -u origin qa You're ready to continuously ship! \u2728 \ud83d\udc85 \ud83d\udef3","title":"Home"},{"location":"#hsvdotbeer","text":"Collate ALL the Huntsville beers. Check out the project's documentation .","title":"hsvdotbeer"},{"location":"#prerequisites","text":"Docker Travis CLI Heroku Toolbelt","title":"Prerequisites"},{"location":"#initialize-the-project","text":"Start the dev server for local development: docker-compose up Create a superuser to login to the admin: docker-compose run --rm web ./manage.py createsuperuser","title":"Initialize the project"},{"location":"#continuous-deployment","text":"Deployment automated via Travis. When builds pass on the master or qa branch, Travis will deploy that branch to Heroku. Enable this by: Creating the production sever: heroku create hsv_dot_beer-prod --remote prod && \\ heroku addons:create newrelic:wayne --app hsv_dot_beer-prod && \\ heroku addons:create heroku-postgresql:hobby-dev --app hsv_dot_beer-prod && \\ heroku config:set DJANGO_SECRET=`openssl rand -base64 32` \\ DJANGO_AWS_ACCESS_KEY_ID=\"Add your id\" \\ DJANGO_AWS_SECRET_ACCESS_KEY=\"Add your key\" \\ DJANGO_AWS_STORAGE_BUCKET_NAME=\"hsv_dot_beer-prod\" \\ --app hsv_dot_beer-prod Creating the qa sever: heroku create `hsv_dot_beer-qa --remote qa && \\ heroku addons:create newrelic:wayne && \\ heroku addons:create heroku-postgresql:hobby-dev && \\ heroku config:set DJANGO_SECRET=`openssl rand -base64 32` \\ DJANGO_AWS_ACCESS_KEY_ID=\"Add your id\" \\ DJANGO_AWS_SECRET_ACCESS_KEY=\"Add your key\" \\ DJANGO_AWS_STORAGE_BUCKET_NAME=\"hsv_dot_beer-qa\" \\ Securely add your heroku credentials to travis so it can automatically deploy your changes. travis encrypt HEROKU_AUTH_TOKEN=\"$(heroku auth:token)\" --add Commit your changes and push to master and qa to trigger your first deploys: git commit -m \"ci(travis): added heroku credentials\" && \\ git push origin master && \\ git checkout -b qa && \\ git push -u origin qa You're ready to continuously ship! \u2728 \ud83d\udc85 \ud83d\udef3","title":"Continuous Deployment"},{"location":"api/authentication/","text":"Authentication For clients to authenticate, the token key should be included in the Authorization HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example: Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example: WWW-Authenticate: Token The curl command line tool may be useful for testing token authenticated APIs. For example: curl -X GET http://127.0.0.1:8000/api/v1/example/ -H 'Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b' Retrieving Tokens Authorization tokens are issued and returned when a user registers. A registered user can also retrieve their token with the following request: Request : POST api-token-auth/ Parameters: Name Type Description username string The user's username password string The user's password Response : { \"token\" : \"9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b\" }","title":"Authentication"},{"location":"api/authentication/#authentication","text":"For clients to authenticate, the token key should be included in the Authorization HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example: Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example: WWW-Authenticate: Token The curl command line tool may be useful for testing token authenticated APIs. For example: curl -X GET http://127.0.0.1:8000/api/v1/example/ -H 'Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b'","title":"Authentication"},{"location":"api/authentication/#retrieving-tokens","text":"Authorization tokens are issued and returned when a user registers. A registered user can also retrieve their token with the following request: Request : POST api-token-auth/ Parameters: Name Type Description username string The user's username password string The user's password Response : { \"token\" : \"9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b\" }","title":"Retrieving Tokens"},{"location":"api/users/","text":"Users Supports registering, viewing, and updating user accounts. Register a new user account Request : POST /users/ Parameters: Name Type Required Description username string Yes The username for the new user. password string Yes The password for the new user account. first_name string No The user's given name. last_name string No The user's family name. email string No The user's email address. Note: Not Authorization Protected Response : Content-Type application/json 201 Created { \"id\": \"6d5f9bae-a31b-4b7b-82c4-3853eda2b011\", \"username\": \"richard\", \"first_name\": \"Richard\", \"last_name\": \"Hendriks\", \"email\": \"richard@piedpiper.com\", \"auth_token\": \"132cf952e0165a274bf99e115ab483671b3d9ff6\" } The auth_token returned with this response should be stored by the client for authenticating future requests to the API. See Authentication . Get a user's profile information Request : GET /users/:id Parameters: Note: Authorization Protected Response : Content-Type application/json 200 OK { \"id\": \"6d5f9bae-a31b-4b7b-82c4-3853eda2b011\", \"username\": \"richard\", \"first_name\": \"Richard\", \"last_name\": \"Hendriks\", \"email\": \"richard@piedpiper.com\", } Update your profile information Request : PUT/PATCH /users/:id Parameters: Name Type Description first_name string The first_name of the user object. last_name string The last_name of the user object. email string The user's email address. Note: All parameters are optional Authorization Protected Response : Content-Type application/json 200 OK { \"id\": \"6d5f9bae-a31b-4b7b-82c4-3853eda2b011\", \"username\": \"richard\", \"first_name\": \"Richard\", \"last_name\": \"Hendriks\", \"email\": \"richard@piedpiper.com\", }","title":"Users"},{"location":"api/users/#users","text":"Supports registering, viewing, and updating user accounts.","title":"Users"},{"location":"api/users/#register-a-new-user-account","text":"Request : POST /users/ Parameters: Name Type Required Description username string Yes The username for the new user. password string Yes The password for the new user account. first_name string No The user's given name. last_name string No The user's family name. email string No The user's email address. Note: Not Authorization Protected Response : Content-Type application/json 201 Created { \"id\": \"6d5f9bae-a31b-4b7b-82c4-3853eda2b011\", \"username\": \"richard\", \"first_name\": \"Richard\", \"last_name\": \"Hendriks\", \"email\": \"richard@piedpiper.com\", \"auth_token\": \"132cf952e0165a274bf99e115ab483671b3d9ff6\" } The auth_token returned with this response should be stored by the client for authenticating future requests to the API. See Authentication .","title":"Register a new user account"},{"location":"api/users/#get-a-users-profile-information","text":"Request : GET /users/:id Parameters: Note: Authorization Protected Response : Content-Type application/json 200 OK { \"id\": \"6d5f9bae-a31b-4b7b-82c4-3853eda2b011\", \"username\": \"richard\", \"first_name\": \"Richard\", \"last_name\": \"Hendriks\", \"email\": \"richard@piedpiper.com\", }","title":"Get a user's profile information"},{"location":"api/users/#update-your-profile-information","text":"Request : PUT/PATCH /users/:id Parameters: Name Type Description first_name string The first_name of the user object. last_name string The last_name of the user object. email string The user's email address. Note: All parameters are optional Authorization Protected Response : Content-Type application/json 200 OK { \"id\": \"6d5f9bae-a31b-4b7b-82c4-3853eda2b011\", \"username\": \"richard\", \"first_name\": \"Richard\", \"last_name\": \"Hendriks\", \"email\": \"richard@piedpiper.com\", }","title":"Update your profile information"},{"location":"beers/beers/","text":"Beers Filtering You can look up beers by the following fields: name (Beer name) abv (Alcohol by volume) __ibu (International Bitterness Units) manufacturer__name (who makes the beer) taps__venue__name (what venue/venues has/have it on tap) style__name (what specific style, e.g. American IPA) style__category__name (what style categor, e.g. IPA) You can also attach specific lookups to narrow/widen your search: For numeric fields: (Nothing appended): exact match __lte : less than or equal to __gte : greater than or equal to __lt : less than __gt : greater than __isnull : boolean (give a value of True or False ) __in : comma-separated list of values For string fields: (Nothing appended): exact match __iexact : case-insensitive exact match __icontains : case-insensitive contains __istartswith : case-insensitive starts with __iendswith : case-insensitive ends with __startswith : case-sensitive starts with __endswith : case-sensitive ends with __contains : case-sensitive contains __regex : matches case-sensitive regex __iregex : matches case-insensitive regex __isnull : boolean (give a value of True or False ) __in : comma-separated list of values To do the filtering, simply GET /beers/?name__icontains=monkey&taps__venue__name__icontains=straight Moderation Have you spotted two beers which should be merged into one? Well you're in luck! Simply fill out this HTTP request: POST /api/v1/beers/<pk>/mergefrom/ (replace <pk> with the ID of the beer you want to keep , described below as \"kept beer\") Body: {\"id\": 123} Replace 123 with the ID of the beer you want to get rid of (described below as \"other beer\") The process: All taps assigned to the other beer are assigned to the kept beer. All fields which are unset (i.e. null or zero) on the kept beer and are set on the other beer will have their values copied over to the kept beer. All fields which are set on the kept beer are untouched. Example: Beer ID 123 Name: \"Hoptastic IPA\" Manufacturer: \"Drew's Basement Brewery\" IBU: 73 ABV: 5.7 Manufacturer URL: http://example.com/beer/Hoptastic Beer ID 456 Name: \"Hoptastic\" Manufacturer: \"Drew's Basement\" IBU: 75 ABV: 6 Color: #abcdef Untappd URL: http://untappd.example.com/beer/122334 Request: POST /api/v1/beers/123/mergefrom/ Body: {\"id\": 456} Result: Beer 456 is deleted Taps assigned to 456 are moved to 123 Fields copied to 123: Color Untappd URL Fields left alone on 123: ABV IBU Manufacturer","title":"Beers"},{"location":"beers/beers/#beers","text":"","title":"Beers"},{"location":"beers/beers/#filtering","text":"You can look up beers by the following fields: name (Beer name) abv (Alcohol by volume) __ibu (International Bitterness Units) manufacturer__name (who makes the beer) taps__venue__name (what venue/venues has/have it on tap) style__name (what specific style, e.g. American IPA) style__category__name (what style categor, e.g. IPA) You can also attach specific lookups to narrow/widen your search: For numeric fields: (Nothing appended): exact match __lte : less than or equal to __gte : greater than or equal to __lt : less than __gt : greater than __isnull : boolean (give a value of True or False ) __in : comma-separated list of values For string fields: (Nothing appended): exact match __iexact : case-insensitive exact match __icontains : case-insensitive contains __istartswith : case-insensitive starts with __iendswith : case-insensitive ends with __startswith : case-sensitive starts with __endswith : case-sensitive ends with __contains : case-sensitive contains __regex : matches case-sensitive regex __iregex : matches case-insensitive regex __isnull : boolean (give a value of True or False ) __in : comma-separated list of values To do the filtering, simply GET /beers/?name__icontains=monkey&taps__venue__name__icontains=straight","title":"Filtering"},{"location":"beers/beers/#moderation","text":"Have you spotted two beers which should be merged into one? Well you're in luck! Simply fill out this HTTP request: POST /api/v1/beers/<pk>/mergefrom/ (replace <pk> with the ID of the beer you want to keep , described below as \"kept beer\") Body: {\"id\": 123} Replace 123 with the ID of the beer you want to get rid of (described below as \"other beer\") The process: All taps assigned to the other beer are assigned to the kept beer. All fields which are unset (i.e. null or zero) on the kept beer and are set on the other beer will have their values copied over to the kept beer. All fields which are set on the kept beer are untouched. Example: Beer ID 123 Name: \"Hoptastic IPA\" Manufacturer: \"Drew's Basement Brewery\" IBU: 73 ABV: 5.7 Manufacturer URL: http://example.com/beer/Hoptastic Beer ID 456 Name: \"Hoptastic\" Manufacturer: \"Drew's Basement\" IBU: 75 ABV: 6 Color: #abcdef Untappd URL: http://untappd.example.com/beer/122334 Request: POST /api/v1/beers/123/mergefrom/ Body: {\"id\": 456} Result: Beer 456 is deleted Taps assigned to 456 are moved to 123 Fields copied to 123: Color Untappd URL Fields left alone on 123: ABV IBU Manufacturer","title":"Moderation"},{"location":"beers/manufacturers/","text":"","title":"Manufacturers"},{"location":"tap_list_providers/parsers/","text":"Parsers What are these? Parsers are a way of taking the data provided by the various API providers and converting them into our format. Some are user-friendly (e.g. they give us raw JSON), but some are not so nice (HTML embedded within a JS object). How does this work? All parsers inherit from the BaseTapListProvider class in tap_list_providers/base.py . To make your own, you need to: Declare a string that identifies your provider, e.g. mybeer . In venues/models.py , edit the TAP_LIST_PROVIDERS attribute of the Venue class to add an entry for your provider in the form ( internal_name , Friendly display name ). If necessary, add fields to the VenueAPIConfiguration model that detail what configuration data is required for your provider (URL, API key, etc.). Create a migration for both of the above: pipenv run ./manage.py makemigrations Create a file named after your provider in tap_list_providers/parsers/ . Your class should inherit from BaseTapListProvider and define the class-level ( not instance-level) attribute provider_name . That attribute must match the internal_name from step 2. You need to implement the method def handle_venue(self, venue) . From there, iterate over the rooms in that venue and fill in data from what you get from the API provider. Utilize the get_beer and get_manufacturer methods from the base class to simplify beer and manufacturer lookup, respectively. Those will automatically create the beers/manufacturers if no match is found (and eventually put them in a moderation queue). If your provider has some sort of unique beer/manufacturer ID (or URL): Add that field to the beer/manufacturer model and create a migration for it. Create a migration for that new field. For beer fields, add that field to the unique_fields local variable in the get_beer() method of the base class. For manufacturer fields, either implement a spacial case as in the if untappd_url block of the get_manufacturer() method or (preferably) refactor the method to use the similar unique_fields logic as get_beer() and then update these docs accordingly. Create a management command to parse all venues for your provider: Create a file called parse<myprovider>.py in tap_list_providers/management/commands/ . Copy and paste the logic from one of the other files and change the references to refer to your code. Save example data in tap_list_providers/example_data . This should be the same data you would get from making the HTTP call to get your data. This way you can use the responses library to fake the result of the HTTP call. Create test code in tap_list_providers/test/ that parses real data (calling the management command) and validates a few of the taps to make sure you get the right example data. Schedule your task: Open http://localhost:8000/admin/ and under Periodic Tasks, select the Add link next to Periodic Tasks. Fields to fill in: Name: Parse <my provider> Task (registered): tap_list_providers.tasks.parse_provider Description: Update all venues from <my provider> Schedule block: Crontab: click the green plus icon Set minute to some value that is not currently used (0, 15, 30, 45) Leave the rest as defaults Click Save Click show next to Arguments . Set the arguments block to [\"internal_name\"] (double quotes are essential) Click SAVE Export the updated schedule: bash pipenv run ./manage.py dumpdata --indent 2 -o tap_list_providers/fixtures/scheduled_tasks.json django_celery_beat.solarschedule django_celery_beat.periodictasks django_celery_beat.periodictask django_celery_beat.intervalschedule django_celery_beat.crontabschedule Commit your changes and create a PR!","title":"Parsers"},{"location":"tap_list_providers/parsers/#parsers","text":"","title":"Parsers"},{"location":"tap_list_providers/parsers/#what-are-these","text":"Parsers are a way of taking the data provided by the various API providers and converting them into our format. Some are user-friendly (e.g. they give us raw JSON), but some are not so nice (HTML embedded within a JS object).","title":"What are these?"},{"location":"tap_list_providers/parsers/#how-does-this-work","text":"All parsers inherit from the BaseTapListProvider class in tap_list_providers/base.py . To make your own, you need to: Declare a string that identifies your provider, e.g. mybeer . In venues/models.py , edit the TAP_LIST_PROVIDERS attribute of the Venue class to add an entry for your provider in the form ( internal_name , Friendly display name ). If necessary, add fields to the VenueAPIConfiguration model that detail what configuration data is required for your provider (URL, API key, etc.). Create a migration for both of the above: pipenv run ./manage.py makemigrations Create a file named after your provider in tap_list_providers/parsers/ . Your class should inherit from BaseTapListProvider and define the class-level ( not instance-level) attribute provider_name . That attribute must match the internal_name from step 2. You need to implement the method def handle_venue(self, venue) . From there, iterate over the rooms in that venue and fill in data from what you get from the API provider. Utilize the get_beer and get_manufacturer methods from the base class to simplify beer and manufacturer lookup, respectively. Those will automatically create the beers/manufacturers if no match is found (and eventually put them in a moderation queue). If your provider has some sort of unique beer/manufacturer ID (or URL): Add that field to the beer/manufacturer model and create a migration for it. Create a migration for that new field. For beer fields, add that field to the unique_fields local variable in the get_beer() method of the base class. For manufacturer fields, either implement a spacial case as in the if untappd_url block of the get_manufacturer() method or (preferably) refactor the method to use the similar unique_fields logic as get_beer() and then update these docs accordingly. Create a management command to parse all venues for your provider: Create a file called parse<myprovider>.py in tap_list_providers/management/commands/ . Copy and paste the logic from one of the other files and change the references to refer to your code. Save example data in tap_list_providers/example_data . This should be the same data you would get from making the HTTP call to get your data. This way you can use the responses library to fake the result of the HTTP call. Create test code in tap_list_providers/test/ that parses real data (calling the management command) and validates a few of the taps to make sure you get the right example data. Schedule your task: Open http://localhost:8000/admin/ and under Periodic Tasks, select the Add link next to Periodic Tasks. Fields to fill in: Name: Parse <my provider> Task (registered): tap_list_providers.tasks.parse_provider Description: Update all venues from <my provider> Schedule block: Crontab: click the green plus icon Set minute to some value that is not currently used (0, 15, 30, 45) Leave the rest as defaults Click Save Click show next to Arguments . Set the arguments block to [\"internal_name\"] (double quotes are essential) Click SAVE Export the updated schedule: bash pipenv run ./manage.py dumpdata --indent 2 -o tap_list_providers/fixtures/scheduled_tasks.json django_celery_beat.solarschedule django_celery_beat.periodictasks django_celery_beat.periodictask django_celery_beat.intervalschedule django_celery_beat.crontabschedule Commit your changes and create a PR!","title":"How does this work?"},{"location":"venues/venues/","text":"Venues These are locations that serve beer/cider/mead/... via taps. Creating a venue Request : POST /api/v1/venues/ Parameters: Name Type Required Description name string Yes A friendly name for the venue (e.g. Sneakers O'Toole's) address string No The street address of the venue city string No The city in which the venue is located state string No The state or province in which the venue is located postal_code string No The zip/postal code of the venue website string No Where to find the venue on the web facebook_page string No Where to find the venue on Facebook twitter_handle string No Where to find the venue on Twitter instagram_handle string No Where to find the venue on Instagram tap_list_provider string No Who provides the venue's digital tap list (DigitalPour, TapHunter, Untappd, etc.) NOTE : tap_list_provider is restricted to the following options: \"manual\" (The venue uses a chalkboard or other such manual means) \"digitalpour\" (DigitalPour) \"taphunter\" (TapHunter) \"untappd\" (Untappd) \"\" (Unknown) \"nook_html\" (The Nook in Huntsville has its own static HTML tap list that requires scraping) Filtering You can look up venues by the following fields: name (Venue name) taps__beer__name (Beer name) taps__beer__style__name (what specific style, e.g. American IPA) taps__beer__style__category__name (what style categor, e.g. IPA) You can also attach specific lookups to narrow/widen your search: For numeric fields: (Nothing appended): exact match __lte : less than or equal to __gte : greater than or equal to __lt : less than __gt : greater than __isnull : boolean (give a value of True or False ) __in : comma-separated list of values For string fields: (Nothing appended): exact match __iexact : case-insensitive exact match __icontains : case-insensitive contains __istartswith : case-insensitive starts with __iendswith : case-insensitive ends with __startswith : case-sensitive starts with __endswith : case-sensitive ends with __contains : case-sensitive contains __regex : matches case-sensitive regex __iregex : matches case-insensitive regex __isnull : boolean (give a value of True or False ) __in : comma-separated list of values To do the filtering, simply GET /venues/?name__icontains=das+stahl&taps__beer__name__icontains=monkey","title":"Venues"},{"location":"venues/venues/#venues","text":"These are locations that serve beer/cider/mead/... via taps.","title":"Venues"},{"location":"venues/venues/#creating-a-venue","text":"Request : POST /api/v1/venues/ Parameters: Name Type Required Description name string Yes A friendly name for the venue (e.g. Sneakers O'Toole's) address string No The street address of the venue city string No The city in which the venue is located state string No The state or province in which the venue is located postal_code string No The zip/postal code of the venue website string No Where to find the venue on the web facebook_page string No Where to find the venue on Facebook twitter_handle string No Where to find the venue on Twitter instagram_handle string No Where to find the venue on Instagram tap_list_provider string No Who provides the venue's digital tap list (DigitalPour, TapHunter, Untappd, etc.) NOTE : tap_list_provider is restricted to the following options: \"manual\" (The venue uses a chalkboard or other such manual means) \"digitalpour\" (DigitalPour) \"taphunter\" (TapHunter) \"untappd\" (Untappd) \"\" (Unknown) \"nook_html\" (The Nook in Huntsville has its own static HTML tap list that requires scraping)","title":"Creating a venue"},{"location":"venues/venues/#filtering","text":"You can look up venues by the following fields: name (Venue name) taps__beer__name (Beer name) taps__beer__style__name (what specific style, e.g. American IPA) taps__beer__style__category__name (what style categor, e.g. IPA) You can also attach specific lookups to narrow/widen your search: For numeric fields: (Nothing appended): exact match __lte : less than or equal to __gte : greater than or equal to __lt : less than __gt : greater than __isnull : boolean (give a value of True or False ) __in : comma-separated list of values For string fields: (Nothing appended): exact match __iexact : case-insensitive exact match __icontains : case-insensitive contains __istartswith : case-insensitive starts with __iendswith : case-insensitive ends with __startswith : case-sensitive starts with __endswith : case-sensitive ends with __contains : case-sensitive contains __regex : matches case-sensitive regex __iregex : matches case-insensitive regex __isnull : boolean (give a value of True or False ) __in : comma-separated list of values To do the filtering, simply GET /venues/?name__icontains=das+stahl&taps__beer__name__icontains=monkey","title":"Filtering"}]}